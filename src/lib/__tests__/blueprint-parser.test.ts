import { parseAndNormalizeBlueprint } from '../blueprint-parser';

describe('parseAndNormalizeBlueprint', () => {

    describe('YAML Parsing Structures', () => {
        test('Structure 1: should correctly parse a standard multi-document YAML with a config header', () => {
            const yamlContent = `
id: yaml-test-v1
title: YAML Test
---
- id: p1
  prompt: What is YAML?
`;
            const result = parseAndNormalizeBlueprint(yamlContent, 'yaml');
            expect(result.id).toBe('yaml-test-v1');
            expect(result.title).toBe('YAML Test');
            expect(result.prompts).toHaveLength(1);
            expect(result.prompts[0].id).toBe('p1');
        });

        test('Structure 2: should correctly parse a stream of prompt documents', () => {
            const yamlContent = `
prompt: First prompt
---
prompt: Second prompt
---
id: p3
prompt: Third prompt
`;
            const result = parseAndNormalizeBlueprint(yamlContent, 'yaml');
            expect(result.id).toBeUndefined();
            expect(result.prompts).toHaveLength(3);
            expect(result.prompts[0].messages?.[0].content).toBe('First prompt');
            expect(result.prompts[2].id).toBe('p3');
        });

        test('Structure 3: should correctly parse a single document with a list of prompts', () => {
            const yamlContent = `
- id: p1
  prompt: "This is a prompts-only file."
- id: p2
  prompt: "This is the second prompt."
`;
            const result = parseAndNormalizeBlueprint(yamlContent, 'yaml');
            expect(result.id).toBeUndefined();
            expect(result.prompts).toHaveLength(2);
            expect(result.prompts[0].id).toBe('p1');
        });

        test('Structure 4: should correctly parse a single document with a prompts key', () => {
            const yamlContent = `
id: single-doc-with-prompts
prompts:
    - id: p1
      prompt: "First prompt"
`;
            const result = parseAndNormalizeBlueprint(yamlContent, 'yaml');
            expect(result.id).toBe('single-doc-with-prompts');
            expect(result.prompts).toHaveLength(1);
            expect(result.prompts[0].id).toBe('p1');
        });

        test('should handle a stream of documents where some are lists', () => {
            const yamlContent = `
prompt: First prompt
---
- prompt: Second prompt
  id: p2
- prompt: Third prompt
  id: p3
`;
            const result = parseAndNormalizeBlueprint(yamlContent, 'yaml');
            expect(result.prompts).toHaveLength(3);
            expect(result.prompts[0].messages?.[0].content).toBe('First prompt');
            expect(result.prompts[1].id).toBe('p2');
        });

        test('should handle config header without prompts (previously considered malformed)', () => {
            const yamlContent = `id: test-config\ntitle: Test Title`;
            const result = parseAndNormalizeBlueprint(yamlContent, 'yaml');
            expect(result.id).toBe('test-config');
            expect(result.title).toBe('Test Title');
            expect(result.prompts).toHaveLength(0);
        });

        test('should handle single prompt document without explicit structure', () => {
            const yamlContent = `prompt: "A single prompt"\nideal: "An ideal response"`;
            const result = parseAndNormalizeBlueprint(yamlContent, 'yaml');
            expect(result.prompts).toHaveLength(1);
            expect(result.prompts[0].messages?.[0].content).toBe('A single prompt');
            expect(result.prompts[0].idealResponse).toBe('An ideal response');
        });

        test('should handle auto-create style multi-document YAML', () => {
            const yamlContent = `title: "Test Auto-Create Blueprint"
description: "A test blueprint generated by auto-create"
---
- prompt: "What is the capital of France?"
  should:
    - "mentions Paris"
    - "provides accurate information"
- prompt: "Explain photosynthesis"
  should:
    - "mentions sunlight"
    - "mentions chlorophyll"
    - "explains the process clearly"`;
            const result = parseAndNormalizeBlueprint(yamlContent, 'yaml');
            expect(result.title).toBe('Test Auto-Create Blueprint');
            expect(result.description).toBe('A test blueprint generated by auto-create');
            expect(result.prompts).toHaveLength(2);
            expect(result.prompts[0].messages?.[0].content).toBe('What is the capital of France?');
            expect(result.prompts[0].points).toHaveLength(2);
            expect(result.prompts[1].messages?.[0].content).toBe('Explain photosynthesis');
            expect(result.prompts[1].points).toHaveLength(3);
        });
    });

    describe('Unified Normalization', () => {
        const complexYaml = `
configId: normalization-test
configTitle: Normalization Test
system: "Global system prompt"
prompts:
  - id: p1
    ideal: "Ideal response"
    system: "Prompt-specific system prompt"
    should:
      - "A simple conceptual point."
      - "Covers the 'prudent man' rule.": "Investment Advisers Act of 1940"
      - $contains: "fiduciary"
      - { fn: "ends_with", fnArgs: "." }
      - { text: "A weighted conceptual point.", weight: 3.0 }
      - { fn: "matches", arg: "[0-9]+", weight: 0.5 }
    should_not:
      - $contains: "guarantee"
    messages:
      - user: "Hello"
      - ai: "Hi there"
`;
        const complexJson = `{
            "id": "normalization-test",
            "title": "Normalization Test",
            "systemPrompt": "Global system prompt",
            "prompts": [
                {
                    "id": "p1",
                    "idealResponse": "Ideal response",
                    "system": "Prompt-specific system prompt",
                    "points": [
                        { "text": "A simple conceptual point.", "multiplier": 1.0 },
                        { "text": "Covers the 'prudent man' rule.", "citation": "Investment Advisers Act of 1940", "multiplier": 1.0 },
                        { "fn": "contains", "fnArgs": "fiduciary", "multiplier": 1.0 },
                        { "fn": "ends_with", "fnArgs": ".", "multiplier": 1.0 },
                        { "text": "A weighted conceptual point.", "multiplier": 3.0 },
                        { "fn": "matches", "fnArgs": "[0-9]+", "multiplier": 0.5 }
                    ],
                    "should_not": [
                       { "fn": "contains", "fnArgs": "guarantee", "multiplier": 1.0 }
                    ],
                    "messages": [
                      { "role": "user", "content": "Hello" },
                      { "role": "assistant", "content": "Hi there" }
                    ]
                }
            ]
        }`;

        const expectedPoints = [
            { text: "A simple conceptual point.", multiplier: 1.0 },
            { text: "Covers the 'prudent man' rule.", citation: "Investment Advisers Act of 1940", multiplier: 1.0 },
            { fn: "contains", fnArgs: "fiduciary", multiplier: 1.0 },
            { fn: "ends_with", fnArgs: ".", multiplier: 1.0 },
            { text: "A weighted conceptual point.", multiplier: 3.0 },
            { fn: "matches", fnArgs: "[0-9]+", multiplier: 0.5 }
        ];

        test.each([
            ['YAML', complexYaml],
            ['JSON', complexJson],
        ])('should correctly and identically normalize a complex %s blueprint', (_, content) => {
            const result = parseAndNormalizeBlueprint(content, content === complexYaml ? 'yaml' : 'json');

            expect(result.id).toBe('normalization-test');
            expect(result.title).toBe('Normalization Test');
            expect(result.system).toBe('Global system prompt');
            expect(result.prompts).toHaveLength(1);

            const prompt = result.prompts[0];
            expect(prompt.id).toBe('p1');
            expect(prompt.promptText).toBeUndefined();
            expect(prompt.idealResponse).toBe("Ideal response");
            expect(prompt.system).toBe("Prompt-specific system prompt");
            expect(prompt.points).toEqual(expectedPoints);
            expect(prompt.should_not).toEqual([{ fn: 'contains', fnArgs: 'guarantee', multiplier: 1.0 }]);
            expect(prompt.messages).toEqual([
                { role: 'user', content: 'Hello' },
                { role: 'assistant', content: 'Hi there' },
            ]);
        });

        test('should correctly parse prompt-level citation in YAML', () => {
            const yamlWithCitation = `
- id: test-prompt
  prompt: "What is Beejamrut?"
  ideal: "Beejamrut is an organic bio-fertilizer."
  citation: "https://www.youtube.com/watch?v=example"
  should:
    - "Should mention organic bio-fertilizer"
`;
            const result = parseAndNormalizeBlueprint(yamlWithCitation, 'yaml');
            
            expect(result.prompts).toHaveLength(1);
            const prompt = result.prompts[0];
            expect(prompt.id).toBe('test-prompt');
            expect(prompt.citation).toBe('https://www.youtube.com/watch?v=example');
            expect(prompt.idealResponse).toBe('Beejamrut is an organic bio-fertilizer.');
            expect(prompt.points).toHaveLength(1);
        });

        test('should correctly parse prompt-level citation in JSON', () => {
            const jsonWithCitation = `{
                "prompts": [
                    {
                        "id": "test-prompt",
                        "promptText": "What is Beejamrut?",
                        "idealResponse": "Beejamrut is an organic bio-fertilizer.",
                        "citation": "https://www.youtube.com/watch?v=example",
                        "points": [
                            { "text": "Should mention organic bio-fertilizer", "multiplier": 1.0 }
                        ]
                    }
                ]
            }`;
            const result = parseAndNormalizeBlueprint(jsonWithCitation, 'json');
            
            expect(result.prompts).toHaveLength(1);
            const prompt = result.prompts[0];
            expect(prompt.id).toBe('test-prompt');
            expect(prompt.citation).toBe('https://www.youtube.com/watch?v=example');
            expect(prompt.idealResponse).toBe('Beejamrut is an organic bio-fertilizer.');
            expect(prompt.points).toHaveLength(1);
        });
        
        test('should generate a stable hash-based ID for a prompt without an ID', () => {
            const yamlContent = `
- prompt: "This prompt needs an ID."
  ideal: "An ideal response."
`;
            const result = parseAndNormalizeBlueprint(yamlContent, 'yaml');
            const prompt = result.prompts[0];
            expect(prompt.id).toBe('hash-d35001ad5740');
        });

        test('should correctly parse prompt-level description and citation in YAML', () => {
            const yamlWithCitation = `
- id: test-prompt
  prompt: "What is Beejamrut?"
  description: "A test prompt about Beejamrut"
  ideal: "Beejamrut is an organic bio-fertilizer."
  citation: "https://www.youtube.com/watch?v=example"
  should:
    - "Should mention organic bio-fertilizer"
`;
            const result = parseAndNormalizeBlueprint(yamlWithCitation, 'yaml');
            
            expect(result.prompts).toHaveLength(1);
            const prompt = result.prompts[0];
            expect(prompt.id).toBe('test-prompt');
            expect(prompt.description).toBe('A test prompt about Beejamrut');
            expect(prompt.citation).toBe('https://www.youtube.com/watch?v=example');
            expect(prompt.idealResponse).toBe('Beejamrut is an organic bio-fertilizer.');
            expect(prompt.points).toHaveLength(1);
        });

        test('should correctly parse prompt-level description and citation in JSON', () => {
            const jsonWithCitation = `{
                "prompts": [
                    {
                        "id": "test-prompt",
                        "promptText": "What is Beejamrut?",
                        "description": "A test prompt about Beejamrut",
                        "idealResponse": "Beejamrut is an organic bio-fertilizer.",
                        "citation": "https://www.youtube.com/watch?v=example",
                        "points": [
                            { "text": "Should mention organic bio-fertilizer", "multiplier": 1.0 }
                        ]
                    }
                ]
            }`;
            const result = parseAndNormalizeBlueprint(jsonWithCitation, 'json');
            
            expect(result.prompts).toHaveLength(1);
            const prompt = result.prompts[0];
            expect(prompt.id).toBe('test-prompt');
            expect(prompt.description).toBe('A test prompt about Beejamrut');
            expect(prompt.citation).toBe('https://www.youtube.com/watch?v=example');
            expect(prompt.idealResponse).toBe('Beejamrut is an organic bio-fertilizer.');
            expect(prompt.points).toHaveLength(1);
        });
    });

    describe('render_as Normalization', () => {
        test('should apply global render_as to all prompts', () => {
            const yamlContent = `
render_as: html
---
- prompt: "Prompt 1"
- prompt: "Prompt 2"
`;
            const result = parseAndNormalizeBlueprint(yamlContent, 'yaml');
            expect(result.prompts[0].render_as).toBe('html');
            expect(result.prompts[1].render_as).toBe('html');
        });

        test('should allow prompt-level render_as to override global setting', () => {
            const yamlContent = `
render_as: html
---
- prompt: "Prompt 1"
  render_as: plaintext
- prompt: "Prompt 2"
`;
            const result = parseAndNormalizeBlueprint(yamlContent, 'yaml');
            expect(result.prompts[0].render_as).toBe('plaintext');
            expect(result.prompts[1].render_as).toBe('html');
        });

        test('should default to markdown when no render_as is specified', () => {
            const yamlContent = `
- prompt: "Prompt 1"
`;
            const result = parseAndNormalizeBlueprint(yamlContent, 'yaml');
            expect(result.prompts[0].render_as).toBe('markdown');
        });

        test('should throw an error for an invalid global render_as value', () => {
            const yamlContent = `
render_as: invalid_value
---
- prompt: "Prompt 1"
`;
            expect(() => parseAndNormalizeBlueprint(yamlContent, 'yaml')).toThrow("Invalid global 'render_as' value. Must be one of: markdown, html, plaintext.");
        });

        test('should throw an error for an invalid prompt-level render_as value', () => {
            const yamlContent = `
- prompt: "Prompt 1"
  render_as: invalid_value
`;
            expect(() => parseAndNormalizeBlueprint(yamlContent, 'yaml')).toThrow("Invalid 'render_as' value on prompt");
        });
    });

    describe('Header Field Normalization', () => {
        test('should correctly parse author as a string', () => {
            const yamlContent = `author: "Test Author"`;
            const result = parseAndNormalizeBlueprint(yamlContent, 'yaml');
            expect(result.author).toBe("Test Author");
        });

        test('should correctly parse author as an object', () => {
            const yamlContent = `author:\n  name: "Test Author"\n  url: "https://example.com"`;
            const result = parseAndNormalizeBlueprint(yamlContent, 'yaml');
            expect(result.author).toEqual({ name: "Test Author", url: "https://example.com" });
        });

        test('should throw an error for invalid author object', () => {
            const yamlContent = `author:\n  url: "https://example.com"`;
            expect(() => parseAndNormalizeBlueprint(yamlContent, 'yaml')).toThrow("Invalid 'author' object: missing 'name' string.");
        });

        test('should correctly parse multiple citations/references', () => {
            const yamlContent = `
title: My Blueprint
citations:
  - title: "First reference"
    url: "https://example.com/1"
  - "Second reference"
  - name: "Third reference"
`;
            const result = parseAndNormalizeBlueprint(yamlContent, 'yaml');
            expect((result as any).references).toEqual([
                { title: 'First reference', url: 'https://example.com/1' },
                { title: 'Second reference', url: undefined },
                { title: 'Third reference', url: undefined }
            ]);
            expect((result as any).citation).toBeUndefined();
            expect((result as any).citations).toBeUndefined();
            expect((result as any).reference).toBeUndefined();
        });

        test('should correctly parse single string citation into references array', () => {
            const yamlContent = `
title: My Blueprint
citation: "My only reference"
`;
            const result = parseAndNormalizeBlueprint(yamlContent, 'yaml');
            expect((result as any).references).toEqual([{ title: 'My only reference', url: undefined }]);
        });

        test('should correctly parse single object reference into references array', () => {
            const yamlContent = `
title: My Blueprint
reference:
  name: "My only reference object"
  url: "https://example.com/obj"
`;
            const result = parseAndNormalizeBlueprint(yamlContent, 'yaml');
            expect((result as any).references).toEqual([{ title: 'My only reference object', url: 'https://example.com/obj' }]);
        });

        test('should throw an error for invalid reference object in array', () => {
            const yamlContent = `references:\n  - url: "https://example.com"`;
            expect(() => parseAndNormalizeBlueprint(yamlContent, 'yaml')).toThrow("Invalid 'reference'/'citation' object: missing 'title' or 'name' string.");
        });
    });

    describe('Error Handling', () => {
        test.each([
            ['Invalid JSON syntax', `{"id": "json-fail", "prompts": [}`, 'json', 'Failed to parse JSON blueprint'],
            ['Empty YAML file', ``, 'yaml', 'YAML blueprint is empty or contains only null documents.'],
            ['Point with text and fn', `- prompt: p\n  should:\n    - point: "t"\n      fn: "f"`, 'yaml', "Point cannot have both 'text' and 'fn' defined"],
            ['Malformed shorthand message', `- prompt: p\n  messages:\n    - { user: "u", assistant: "a" }`, 'yaml', 'Each message in the shorthand format must have exactly one key'],
            ['Invalid multiplier value', `- prompt: p\n  should:\n    - point: "bad weight"\n      weight: 101`, 'yaml', 'Point multiplier must be a number between 0.1 and 10'],
            ['Invalid point format', `- prompt: p\n  should:\n    - 123`, 'yaml', 'Point must be a string, array, or object'],
            ['Point object with no valid content', `- prompt: p\n  should:\n    - weight: 2.0`, 'yaml', "Point must define 'text', a function ('fn' or '$...'), or a 'Point: Citation' pair"]
        ])('should throw for %s', (_, content, type, expectedError) => {
            expect(() => parseAndNormalizeBlueprint(content, type as 'yaml' | 'json')).toThrow(expectedError);
        });
    });

    describe('Alternative Paths (Nested Arrays)', () => {
        test('should parse nested arrays as alternative paths', () => {
            const yamlWithNestedArrays = `
- prompt: "Test prompt"
  should:
    - - "is kind and polite"
      - $contains: "recipe"
    - - "asks clarifying questions"
      - "offers to help"
`;
            const result = parseAndNormalizeBlueprint(yamlWithNestedArrays, 'yaml');
            
            expect(result.prompts).toHaveLength(1);
            const prompt = result.prompts[0];
            expect(prompt.points).toBeDefined();
            
            // The parser should preserve the nested structure
            expect(prompt.points).toEqual([
                [
                    { text: "is kind and polite", multiplier: 1.0 },
                    { fn: "contains", fnArgs: "recipe", multiplier: 1.0 }
                ],
                [
                    { text: "asks clarifying questions", multiplier: 1.0 },
                    { text: "offers to help", multiplier: 1.0 }
                ]
            ]);
        });

        test('should handle mixed flat and nested arrays', () => {
            const yamlWithMixed = `
- prompt: "Test prompt"
  should:
    - "always required point"
    - - "path 1 point A"
      - "path 1 point B"
    - - "path 2 single point"
    - $contains: "always required word"
`;
            const result = parseAndNormalizeBlueprint(yamlWithMixed, 'yaml');
            
            expect(result.prompts).toHaveLength(1);
            const prompt = result.prompts[0];
            expect(prompt.points).toBeDefined();
            
            // Should handle both flat and nested structures
            expect(prompt.points).toEqual([
                { text: "always required point", multiplier: 1.0 },
                [
                    { text: "path 1 point A", multiplier: 1.0 },
                    { text: "path 1 point B", multiplier: 1.0 }
                ],
                [
                    { text: "path 2 single point", multiplier: 1.0 }
                ],
                { fn: "contains", fnArgs: "always required word", multiplier: 1.0 }
            ]);
        });

        test('should handle nested arrays in should_not', () => {
            const yamlWithNestedShouldNot = `
- prompt: "Test prompt"
  should_not:
    - - "is rude"
      - "is dismissive"
    - - "provides misinformation"
`;
            const result = parseAndNormalizeBlueprint(yamlWithNestedShouldNot, 'yaml');
            
            expect(result.prompts).toHaveLength(1);
            const prompt = result.prompts[0];
            expect(prompt.should_not).toBeDefined();
            
            expect(prompt.should_not).toEqual([
                [
                    { text: "is rude", multiplier: 1.0 },
                    { text: "is dismissive", multiplier: 1.0 }
                ],
                [
                    { text: "provides misinformation", multiplier: 1.0 }
                ]
            ]);
        });

        test('should handle empty nested arrays gracefully', () => {
            const yamlWithEmptyArrays = `
- prompt: "Test prompt"
  should:
    - []
    - - "valid point"
    - []
`;
            const result = parseAndNormalizeBlueprint(yamlWithEmptyArrays, 'yaml');
            
            expect(result.prompts).toHaveLength(1);
            const prompt = result.prompts[0];
            expect(prompt.points).toBeDefined();
            
            // Should filter out empty arrays
            expect(prompt.points).toEqual([
                [
                    { text: "valid point", multiplier: 1.0 }
                ]
            ]);
        });

        test('should preserve backwards compatibility with flat arrays', () => {
            const yamlWithFlatArrays = `
- prompt: "Test prompt"
  should:
    - "simple point"
    - $contains: "word"
    - { fn: "ends_with", fnArgs: "." }
`;
            const result = parseAndNormalizeBlueprint(yamlWithFlatArrays, 'yaml');
            
            expect(result.prompts).toHaveLength(1);
            const prompt = result.prompts[0];
            expect(prompt.points).toBeDefined();
            
            // Should handle flat arrays as before
            expect(prompt.points).toEqual([
                { text: "simple point", multiplier: 1.0 },
                { fn: "contains", fnArgs: "word", multiplier: 1.0 },
                { fn: "ends_with", fnArgs: ".", multiplier: 1.0 }
            ]);
        });
    });

    describe('noCache Normalization', () => {
        test('should correctly parse noCache flag on a prompt', () => {
            const yamlContent = `
- id: p1
  prompt: "This should be cached"
- id: p2
  prompt: "This should not be cached"
  noCache: true
- id: p3
  prompt: "This should also be cached"
  noCache: false
`;
            const result = parseAndNormalizeBlueprint(yamlContent, 'yaml');
            expect(result.prompts).toHaveLength(3);
            expect(result.prompts[0].noCache).toBe(undefined);
            expect(result.prompts[1].noCache).toBe(true);
            expect(result.prompts[2].noCache).toBe(false);
        });

        test('should handle global noCache with prompt-level overrides', () => {
            const yamlContent = `
noCache: true
---
- id: p1
  prompt: "Inherits global noCache=true"
- id: p2
  prompt: "Overrides global with noCache=false"
  noCache: false
- id: p3
  prompt: "Explicitly sets noCache=true"
  noCache: true
`;
            const result = parseAndNormalizeBlueprint(yamlContent, 'yaml');
            expect(result.prompts).toHaveLength(3);
            expect(result.prompts[0].noCache).toBe(true); // Inherited
            expect(result.prompts[1].noCache).toBe(false); // Overridden
            expect(result.prompts[2].noCache).toBe(true); // Explicit
        });
    });
}); 